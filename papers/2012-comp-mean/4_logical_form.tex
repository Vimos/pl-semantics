\section{Transforming natural language text to logical form}

In transforming natural language text to logical form, we build on the software
package Boxer \citep{bos:coling2004}. % Boxer
% is an extension to the C\&C parser \citep{clark:acl04} that transforms a parsed 
% discourse of one or more sentences into a semantic representation.  Boxer
% outputs the meaning of each discourse as a Discourse Representation Structure
% (DRS) that closely resembles the structures described by \citet{kamp:book93}.
%
We chose to use Boxer for two main reasons.  First, Boxer is a
wide-coverage system that can deal with arbitrary text. 
%  that is able to return a reasonable logical representation
% of most English sentences.  Since our goal is to work with actual texts,
% it is critical that we have a wide-coverage semantic parser.  If
% we did not, then we would be unable to deal with any but the simplest texts. 
Second, the DRSs that Boxer produces are close to the standard first-order
logical forms that are required for use by the MLN software package 
Alchemy.  Our system transforms Boxer output into a format that Alchemy can read and 
augments it with additional information.

To demonstrate our transformation procedure, consider again the premise of
example \eqref{ex:imp-fact-nested}.  When given to Boxer, the sentence produces
the output given in Figure \ref{fig:boxer-drs}.  We then transform this output
to the format given in Figure \ref{fig:canonical-drs}.


\begin{small}
\begin{figure}
  \centering
  \subfloat[Output from Boxer]{\label{fig:boxer-drs}
		\dhgdrs{}{{\footnotesize x0~ x1}}{
			{\footnotesize named(x0,ed,per)} \\
			\vspace{-.7ex}
			{\footnotesize named(x1,dave,per)} \\
			\vspace{-.7ex}
			\dhgnegdrs{{\footnotesize x2~ x3}}{
				\vspace{-.7ex}
				{\footnotesize forget(x2)} \\
				\vspace{-.7ex}
				{\footnotesize event(x2)} \\
				\vspace{-.7ex}
				{\footnotesize agent(x2,x0)} \\ 
				\vspace{-.7ex}
				{\footnotesize theme(x2,x3)} \\ 
				\vspace{-.7ex}
				\dhgdrs{{\footnotesize x3:}}{{\footnotesize x4~ x5}}{
					\vspace{-.7ex}
					{\footnotesize arrange(x4)} \\ 
					\vspace{-.7ex}
					{\footnotesize event(x4)} \\ 
					\vspace{-.7ex}
					{\footnotesize agent(x4,x0)} \\
					\vspace{-.7ex}
					{\footnotesize theme(x4,x5)} \\ 
					\vspace{-.7ex}
					\dhgdrs{{\footnotesize x5:}}{{\footnotesize x6}}{ 
						\vspace{-.7ex}
						{\footnotesize fail(x6)} \\ 
						\vspace{-.7ex}
						{\footnotesize event(x6)} \\ 
						\vspace{-.7ex}
						{\footnotesize agent(x6,x1)}
						\vspace{-2ex}
					} 
					\vspace{-1.5ex}
				} 
				\vspace{-1.5ex}
			}
			\vspace{-1.5ex}
		}
	}                
  ~~$\xrightarrow{\text{ transforms to }}$
  \subfloat[Canonical form]{\label{fig:canonical-drs}
  	\dhgboxed{
		\vspace{-.7ex}
		{\footnotesize named(l0, ne\_per\_ed\_d\_s0\_w0, z0)} \\
		\vspace{-.7ex}
		{\footnotesize named(l0, ne\_per\_dave\_d\_s0\_w7, z1)} \\
		\vspace{-.7ex}
		{\footnotesize not(l0, l1)} \\
		\vspace{-.7ex}
		{\footnotesize pred(l1, v\_forget\_d\_s0\_w3, e2)} \\
		\vspace{-.7ex}
		{\footnotesize event(l1, e2)} \\
		\vspace{-.7ex}
		{\footnotesize rel(l1, agent, e2, z0)} \\
		\vspace{-.7ex}
		{\footnotesize rel(l1, theme, e2, l2)} \\
		\vspace{-.7ex}
		{\footnotesize prop(l1, l2)} \\
		\vspace{-.7ex}
		{\footnotesize pred(l2, v\_arrange\_d\_s0\_w5, e4)} \\
		\vspace{-.7ex}
		{\footnotesize event(l2, e4)} \\
		\vspace{-.7ex}
		{\footnotesize rel(l2, agent, e4, z0)} \\
		\vspace{-.7ex}
		{\footnotesize rel(l2, theme, e4, l3)} \\
		\vspace{-.7ex}
		{\footnotesize prop(l2, l3)} \\
		\vspace{-.7ex}
		{\footnotesize pred(l3, v\_fail\_d\_s0\_w8, e6)} \\
		\vspace{-.7ex}
		{\footnotesize event(l3, e6)} \\
		\vspace{-.7ex}
		{\footnotesize rel(l3, agent, e6, z1)}
		\vspace{-2ex}
	}
  }
  \caption{Converting the premise of \eqref{ex:imp-fact-nested} from
  Boxer output to MLN input}
  \label{fig:boxer-conversion}
\end{figure}
\end{small}

\noindent\textbf{Flat structure.}
In Boxer output, nested propositional statements are represented as nested sub-DRS structures.
  For example, in the premise of
(\ref{ex:imp-fact-nested}), the verbs ``forget to'' and ``arrange that'' both
introduce nested propositions, as is shown in Figure \ref{fig:boxer-drs} where
DRS {\it x3} (the ``arranging that'') is the {\it theme} of ``forget to'' and
DRS {\it x5} (the ``failing'') is the {\it theme} of ``arrange that''.  

In order to write logical rules about the truth conditions of nested
propositions, the structure has to be flattened. However, it is
clearly not sufficient to just conjoin all propositions at the top
level. Such an approach, applied to example
\eqref{ex:hope-build}, would yield $(hope(x_1) \land theme(x_1, x_2)
\land build(x_2) \land \ldots)$, leading to the wrong inference that
the stadium was built. 
Instead, we add a new argument to each predicate that names the DRS in
which the predicate originally occurred. Assigning the label
\textit{l1} to the DRS containing the predicate \textit{forget}, we
add {\it l1} as the first argument to the atom
{\it pred(l1, v\_forget\_d\_s0\_w3, e2)}.\footnote{The extension to the word,
such as {\it d\_s0\_w3} for ``forget'', is an index providing the location of
the original word that triggered this atom; this is addressed in more detail
shortly.} Having flattened the structure, we need to re-introduce the
information about relations between DRSs. For this we use predicates {\it not}, {\it imp},
and {\it or} whose arguments are DRS labels. For example, $not(l0, l1)$ states 
that $l1$ is inside $l0$ and negated.  Additionally, an atom $prop(l0, l1)$
indicates that DRS $l0$ has a subordinate DRS labeled $l1$.  

One important consequence of our flat structure is that the truth
conditions of our representation no longer coincide with the truth conditions of
the underlying DRS being represented.  
For example, we do not directly express the fact that the ``forgetting'' is actually
negated, since the negation is only expressed as a relation between DRS
labels. 
To access the information encoded in relations between DRS labels, we
add predicates that
capture the truth conditions of the underlying DRS.  We use the  predicates
$true(label)$ and $false(label)$ that state whether the DRS referenced by
$label$ is {\it true} or {\it false}.  We also add rules that
govern how the predicates for logical operators interact with these truth
values.  For example, the rules in \eqref{ex:neg-op-rules} state that if a DRS
is {\it true}, then any negated subordinate must be {\it false} and vice versa.

\begin{equation}\label{ex:neg-op-rules}
\forall~p~n.[not(p,n) \rightarrow (true(p) \leftrightarrow false(n)) \land
(false(p) \leftrightarrow true(n))]
\end{equation}


\noindent\textbf{Injecting additional information into the logical form.}
We want to augment Boxer output with additional
information, for example gold coreference annotation for sentences
that we subsequently analyze with Boxer. In order to do so, we need to
be able to tie predicates in the Boxer output back to words in the
original sentence. Fortunately, the optional ``Prolog'' output format from Boxer
provides the sentence and word indices from the original sentence.  When
parsing the Boxer output, we extract these indices and concatenate them to the
word lemma to specific the exact occurrence of the lemma that is under
discussion.  For example, the atom {\it pred(l1, v\_forget\_d\_s0\_w3, e2)}
indicates that event {\it e2} refers to the lemma ``forget'' that appears in the
$0^{th}$ sentence of discourse {\it d} at word index 3.


\noindent\textbf{Atomic formulas.}
We represent the words from the sentence as arguments instead of
predicates in order to simplify the set of inference rules we need to
specify. Because our flattened structure requires that the inference
mechanism be reimplemented as a set of logical rules, it is desirable
for us to be able to write general rules that govern the interaction
of atoms. With the representation we have chosen, we can quantify over
all predicates or all relations. For example, the rule in
\eqref{ex:second-order-rule} states that a predicate is accessible if
it is found in an out-scoping DRS.
%  If, instead, we used atoms such as
% {\it forget(l1, e2)} and {\it agent(l1, e2, z0)} then we would be
% unable to write such simple inference rules since this would require
% quantification over predicates, a second-order property unavailable
% for first-order inference.

\begin{equation}\label{ex:second-order-rule}
\forall~l_1~l_2.[outscopes(l_1,l_2) \rightarrow \forall~p~x.[pred(l_1,p,x) \rightarrow pred(l_2,p,x)]]
\end{equation}
 
We use three different predicate symbols to distinguish three types of atomic concepts: predicates, named entities, and
relations.  Predicates and named entities represent words that appear in the
text.  For example, {\it named(l0, ne\_per\_ed\_d\_s0\_w0, z0)} indicates that
variable {\it z0} is a person named ``Ed'' while 
{\it pred(l1, v\_forget\_d\_s0\_w3, e2)} says that {\it e2} is a
``forgetting to'' event.  
Relations capture the relationships between words.  For example, 
{\it rel(l1, agent, e2, z0)} indicates that {\it z0}, ``Ed'', is the ``agent''
of the ``forgetting to'' event {\it e2}.



