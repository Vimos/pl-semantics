package utcompling.mlnsemantics.inference

import org.apache.commons.logging.LogFactory
import scala.io.Source
import scala.math._
import utcompling.scalalogic.top.expression._
import utcompling.scalalogic.base.expression._
import utcompling.scalalogic.fol.expression._
import utcompling.scalalogic.fol.expression.parse.FolLogicParser
import opennlp.scalabha.util.FileUtils._
import opennlp.scalabha.util.FileUtils
import opennlp.scalabha.util.CollectionUtils._
import opennlp.scalabha.util.CollectionUtil._
import utcompling.scalalogic.util.SubprocessCallable
import utcompling.mlnsemantics.inference.support._
import java.util.StringTokenizer
import utcompling.mlnsemantics.run.Sts

class AlchemyTheoremProver(
  override val binary: String,
  prior: Double = -3,
  var entWeight: Double = 1,
  logBase: Double = E)
  extends SubprocessCallable(binary)
  with ProbabilisticTheoremProver[FolExpression] {

  type WeightedFolEx = WeightedExpression[FolExpression]

  private val LOG = LogFactory.getLog(classOf[AlchemyTheoremProver])

  private val entailedConst = ("entail" -> Set("entailed"))
  private var entailedDec = FolVariableExpression(Variable("entailment")) -> Seq("entail")
  private var entailmentConsequent = FolAtom(Variable("entailment"), Variable("entailed")); //FolVariableExpression(Variable("entailment")) -> Seq("");//= 
  private var ResultsRE = """entailment\("entailed"\) (\d*\.\d*)""".r
  
  override def prove(
    constants: Map[String, Set[String]],
    declarations: Map[FolExpression, Seq[String]],
    evidence: List[FolExpression],
    assumptions: List[WeightedFolEx],
    goal: FolExpression): Option[Double] = {

    declarations.foreach { dec =>
      dec match {
        case (FolAtom(Variable(pred), args @ _*), argTypes) =>
          for (a <- argTypes)
            require(constants.contains(a), "No contants were found for type '%s' of declared predicate '%s'.".format(a, pred))
        case d => throw new RuntimeException("Only atoms may be declared.  '%s' is not an atom.".format(d))
      }
    }
    
    
/*  // This block to add all variables to the entailment clause. I may need it back one day
    val variables: Set[Variable] = findVars(goal);
    var queryParam : String = """entailment\("entailed",""";
    var typeParam : List[String]= List("entail");
    for (v <- variables )
    {
    	  //println(v+"\n")
    	  queryParam += """""""+v.name.toUpperCase() + """",""";
     	  entailmentConsequent = FolApplicationExpression(entailmentConsequent, FolVariableExpression(Variable(v.name)));
    	  if (v.name.charAt(1) == 'x')
    	    typeParam ::= "indv";
    	  else if (v.name.charAt(1) == 'e')
    	    typeParam ::= "evnt";
    	  else if (v.name.charAt(1) == 'p')
    	    typeParam ::= "prop";
    	  else throw new RuntimeException ("unsupported type");
    }
    queryParam = queryParam.substring(0, queryParam.length()-1)+"""\) (\d*\.\d*)""";
    ResultsRE = queryParam.r;
    typeParam = typeParam.reverse;
    entailedDec = FolVariableExpression(Variable("entailment")) -> typeParam;
 */
    
    val declarationNames =
      (declarations + entailedDec).mapKeys {
        case FolAtom(Variable(pred), _*) => pred
        case FolVariableExpression(Variable(pred)) => pred
      }
    
    
    val mlnFile = makeMlnFile(
      constants + entailedConst,
      declarationNames,
      assumptions,
      evidence,
      goal)
      
    val evidenceFile = makeEvidenceFile(evidence)
    val resultFile = FileUtils.mktemp(suffix = ".res")

    //Adding all predicates to the query force them to be open world
    //This could be slower but, this is the only way to set the predicates to open-world in 
    //Alchamy 2.0 because they removed this option
    //val args = List("-ow", declarationNames.keys.mkString(","), "-q", "entailment")
    //val args = List( "-q", declarationNames.keys.mkString(","))
    
    //all evd are in the mln file
    val args = List( "-q", "entailment")

    //old call for alchemy.
    /*callAlchemy(mlnFile, evidenceFile, resultFile, args) map {
      case ResultsRE(score) => score.toDouble
      case err => sys.error(err)
    }*/
    //Output has many lines
    try 
    {
	    val result = callAlchemy(mlnFile, evidenceFile, resultFile, args);
	    result match 
	    {
	      case Some(x) =>
	      {
	        val outputLines =  x.split("\n");
	        var maxScore: Double = -1;
	        var bestWorld: String = "";
	        for (line <- outputLines)
	        {
	         val lineSplits = line.split(" ");
	          if (lineSplits.length == 2)
	          {
		          val score = lineSplits(1).toDouble;
		          if (score > maxScore && lineSplits(0).startsWith("entailment"))
		          {
		        	  maxScore = score;
		        	  bestWorld = lineSplits(0);
		          }
	          }
	        }
	        if (maxScore == -1)
	          throw new RuntimeException("no valid output in the result file");
	        else
	        	return Some(maxScore);
	      }      
	      case None => throw new RuntimeException("empty result file");
	    }
    }catch 
    {
    	case e: Exception =>{
    	  println (e);
    	  return Some(-1.0);
    	}   				 
    }
    
  }

  private def makeMlnFile(
    constants: Map[String, Set[String]],
    declarationNames: Map[String, Seq[String]],
    assumptions: List[WeightedFolEx],
    evidence: List[FolExpression],
    goal: FolExpression) = {
    
    var reducedConstants = constants;
    for (s <- constants)
    {
      if (s._2.size > 1)
		{
			var constsList: Set[String] =Set();
			for(c<- s._2)
			{
				if(!c.startsWith("default"))
					constsList = constsList + c;
			}
         reducedConstants = reducedConstants + (s._1 -> constsList); 
		}
    }
    
    val tempFile = FileUtils.mktemp(suffix = ".mln")
    FileUtils.writeUsing(tempFile) { f =>
      reducedConstants.foreach {
        case (name, tokens) => f.write("%s = {%s}\n".format(name, tokens.map(quote).mkString(",")))
      }
      f.write("\n")

      declarationNames.foreach {
        case (pred, varTypes) => f.write("%s(%s)\n".format(pred, varTypes.mkString(",")))
      }
      f.write("\n")

      declarationNames.foreach {
        //different priors for ent and other predicates 
        case ("entailment", varTypes) => f.write("%s !%s(%s)\n".format(-prior, "entailment", varTypes.indices.map("z" + _).mkString(",")))
        case (pred, varTypes) => f.write("%s !%s(%s)\n".format(-prior, pred, varTypes.indices.map("z" + _).mkString(",")))
      }
      f.write("\n")

      val weightThreshold  = Sts.opts.get("-wThr") match {
			case Some(thr) => thr.toDouble;
			case _ => 0.0001;
		}
		assumptions
        .flatMap {
          case e @ SoftWeightedExpression(folEx, weight) =>
            weight match {
              case Double.PositiveInfinity => Some(HardWeightedExpression(folEx))
              case Double.NegativeInfinity => None ;//Some(HardWeightedExpression(-folEx))
              case _ if weight < weightThreshold => None
              case _ => Some(e)
            }
          case e @ HardWeightedExpression(folEx) => Some(e)
        }.foreach { e => 
          e match {
	          case SoftWeightedExpression(folExp, weight) =>
	            // DONE: Convert [0,1] weight into alchemy weight
	            //            val usedWeight = log(weight / (1 - weight)) / log(logBase) // treat 'weight' as a prob and find the log-odds
	            //            f.write(usedWeight + " " + convert(folEx) + "\n")
	            var usedWeight = min(weight, 0.999);
	            usedWeight = max(usedWeight, 0.001);
	            usedWeight = -prior + log(usedWeight) - log(1-usedWeight);
	            if (usedWeight  > 0)
	            {
	              val folExpString = convert(folExp);
	              //This is a nasty hack to inverse what alchamy does when it splits a formula into smaller formulas
	              var count = folExpString.split("=>").apply(1).count(_ == '^') + 1;
					  Sts.opts.get("-scaleW") match {
							case Some(s) => s.toBoolean match {
								case false => count = 1;
								case _ =>;
							} 
							case _ => ;
					  }
	              usedWeight = usedWeight * count; 
	              f.write("%.15f %s\n".format(usedWeight, folExpString))
	            }
	            //val usedWeight = 10 * weight // 5 * (pow(weight, 10)) //DONE: Set these parameters!!
	            // DONE: we want to design a function `f` such that, for the simplest examples (only one weighted clause), mln(f(s)) == s
	            //   meaning that the probability of entailment (`mln`) using a weight `f(s)` based on similarity score `s <- [0,1]` will be
	            //   roughly equal to the similarity score itself.
	            
	          case HardWeightedExpression(folExp) => f.write(convert(folExp) + ".\n")
         }
       }

      f.write("\n")
      
      //f.write(handwrittenRules);
      
      val entWeights = Array(0.0); 
    		  //1.00502956135076,0.78468486594218,0.123046498860162,0.162995244840038,1.03924551423102,0.94132639047497,1.83737056121309,0.437743834609839,2.05298330711701,0.575985207460632,1.96171216485545,0.295109370169261,0.78468486594218,1.65828520113444,0.544342230077137,0.336481539356268,0.980856082427725,0.632560243489525,0.980856082427725,0.472941329417056,1.19232553583432,0.809987345027389,0.940566951847209,1.61036900770078,0.535042848421037,0.392676737219095,0.769928737659895,0.588840475672007,0.980856082427725,0.930297466276311,0.516432897915679,0.516432897915679,0.434275022488227,0.516432897915679,0.980856082427725,0.726828097656731,0.353343388517051,0.280326984373939,0.980856082427725,0.980856082427725,0.980856082427725,0.952551843955434,0.629875451463382,0.376573769224991,0.376573769224991,0.308602383644355,0.351703277676016,0.394618005821876,0.376573769224991,0.376573769224991,1.61001054647198,0.696038888558247,0.584532841958785,0.836993918464751,0.980856082427725,0.592349198828874,0.668962407136283,0.592349198828874,2.2778537450786,0.712564855687933,0.69854701507995,1.33330098261473,3,0.980856082427725,0.574522312844372,0.459643120592053,0.434780620425545,0.980856082427725,1.03505554412769,0.354012093243939,0.804571442485091,0.08,0.980856082427725,0.980856082427725,1.71964115812337,0.366711436979562,0.897400784909194,0.66492851641247,1.83801961445382,0.27049611187343,0.936923465509526,0.936923465509526,0.262311280207676,0.418458561711292,0.355382972649562,0.283510583395721,0.356160281840896,0.566458935252567,0.620996670967564,1.15949503537106,0.47677066661989,0.735439405024366,0.380329012707923,0.303141451956861,0.601477615859016,0.384866627464858,0.771251094522857,0.980856082427725,0.48074540269509,0.46875058960782,0.554854592385956,0.846171926476095,0.273426179598552,1.01237944225716,0.384830986151457,0.435598260033667,0.428202316312692,0.426923368709129,0.361483351220371,1.34993520195576,0.381548322409071,0.298626002608211,0.37584684424789,0.472929125738226,0.670424701965542,0.395501122516112,0.797852015061396,1.28801003938861,0.209402890025152,0.394618005821876,0.6021595543072,0.580446742820765,0.08,0.867530035720095,0.753715020594918,0.944604908355414,0.314301050187879,0.285101456681854,0.336126592413447,0.536471360863139,0.348395902986323,0.336126592413447,1.30780810990363,0.409301303662146,0.796067015520983,0.677959722878209,0.329121750633736,0.39652670144596,0.349256750483057,0.262533819685805,0.287863241531978,0.393876820449975,0.322593308075605,1.51169215634389,0.525648135041939,0.687129615969222,0.590241970579431,0.273660348931209,0.3632251861193,0.567055621957483,0.476965793770985,3,0.712752247099311,0.08,1.03069579392207,0.384982449658938,0.860551920207361,0.980856082427725,0.592143283956076,0.660866270114718,0.660866270114718,0.534029682524824,0.576994993071317,0.956884736071696,0.380447466302775,0.357904392666477,0.534182145189196,0.498164657161171,0.621674574096014,0.38647398565616,0.527118413585004,0.992250168803192,0.562374533954421,0.370749205768141,0.42120922851796,0.842700487663653,0.686695207290858,0.561638701500146,1.04606376206015,0.413080140807579,0.08,0.128858497185939,0.08,0.386830628631063,0.330802927189868,0.595704166202725,0.88971804098925,0.920666931689674,0.08,0.926585577643331,0.302705974804149,0.463632846067941,0.461700493814116,0.374871084295606,1.59540427069332,0.946822527718813,0.08,0.536333373178547,0.853676500660088,0.08,0.753347535620322,0.472672227479815,1.40954347394773,0.337121360271374,0.980856082427725,0.62113598944698,0.325440092854394,0.43217336146525,0.431210739158027,0.789211407956208,0.533652336017405,0.954523931744726,0.352713088874768,0.362189300088096,0.980856082427725,0.133081141202394,0.243385460726889,0.369703567215037,1.31121969819059,0.761509042761108,0.54667541980626,0.281939293307264,2.05654369460731,0.675489889465499,0.354844893670563,0.632465920196523,0.89206625048862,0.642718399013053,0.587867733039294,0.642807897851375,1.18963749270309,0.554323090170969,0.933860949437691,0.582411021542929,0.318934581612676,0.271747504965913,0.882523728808889,1.20346328186107,1.23336443971739,1.91231077749608,0.711791155248743,0.722497807851623,0.524200058962451,0.326762440094278,1.72271983431195,0.08,1.25231307524935,0.586619772951575,0.360332969038884,0.79891756898462,0.08,0.450642687183669,0.451218120793398,0.5737662574335,0.855142848629996,0.291276443411958,0.410430005386785,0.56745320995361,0.326736128381383,0.624914568767715,0.25992375304471,0.475506194739211,0.495293650169307,0.34804852920229,0.416748421439411,0.578240198084685,0.317940438709797,0.739397432569989,0.991514249889227,0.845397826182601,0.515289692048868,0.527143946964906,0.947230662501219,0.580023319007254,0.419335236977484,0.422645113152176,0.406605008323816,0.900544090461708,0.463362270559808,0.38138930642085,0.351231618226405,0.79429763474435,0.721668612288318,0.26311448218672,0.412796951080149,0.370276204796121,0.390010418882585,0.220035250992118,0.251946805131012,0.656905108659415,0.453786673668512,0.08,0.08,0.08,0.842891470614197,0.473262671111945,0.931531765507354,1.03640209037454,0.385891772656988,0.08,0.601465029772096,0.58480977481439,0.822151020160356,0.458786114274422,0.222927039344222,0.710492973170236,0.42702375024772,0.568839806947678,0.66418921832539,0.784084499629151,0.45230481873107,0.841323429906033,1.01697051624057,0.290649305103591,0.08,0.52523246223387,2.05298330711701,0.386573196384143,1.4362378513791,0.345108381185007,0.258704184916878,0.342295477320837,1.65342866703442,0.568839806947678,0.667838185231416,0.443825806145168,0.08,0.590060194138406,0.45592074274532,0.682010508830596,0.08,0.559966713895575,0.975257444925674,0.78988209024222,0.467163692348842,0.224757868352527,0.566602607495074,0.306950069585338,0.585648676465475,0.506143591030157,0.514804660943801,0.595699642602453,0.43679084351288,0.08,0.41450647122144,0.703272229672286,0.256223251402568,0.61018230974434,0.639961958737799,0.915161547892802,0.08,0.34546289255191,1.3883992115839,1.94716578399987,0.440102579483541,0.276604226951647,0.08,0.290637621980425,0.372046343077678,0.262721825870832,0.515333786507785,1.04423909718328,0.287403649533109,1.32600199570595,1.02765342212209,0.08,0.08,0.474307412181825,0.08,0.303155175285591,0.08,0.19668091441044,0.08,0.08,0.97254856925134,0.439514356724503,0.440149812026229,0.696349361109667,0.08,0.305225215096926,0.509778074428823,2.2491319771106,0.445846657866234,0.128926242347247,0.08,0.08,1.07949060283748,0.676852079713538,0.558612383189866,0.291891035878854,0.657707137035173,0.08,0.490715186321238,0.792600573701522,0.223612175196797,0.261387346188896,0.212466523390837,0.765144711878128,0.568309322254152,0.857736294252266,0.383783810968582,1.10786699578298,0.284003669120284,1.53080599598958,1.63935595746925,0.11841409108579,0.380553119513221,0.279041381875123,0.539736057311778,0.62856151657961,0.771355116213021,0.605423883950471,1.58745853923932,0.500529739086439,1.18493583136527,0.446777939611794,1.10944010845696,1.6058335997076,0.856806188823416,0.855815939591618,0.529045793040078,0.08,0.653631612142844,0.871323121993423,0.970278140811948,0.639476571010566,0.562874614172544,0.08,0.08,0.171177635372819,0.652432929901931,0.224817912405359,0.453906209741908,0.729171783288902,0.530858942204874,1.15734556161703,0.333355613338593,0.518157308506658,3,0.518522456601584,0.77668315745402,0.08,0.288025147195117,0.249876793937049,0.549682938812272,0.246405742634588,0.443561590999328,0.08,0.08,0.08,0.503388634077238,0.540292874202923,3,0.322294215165315,0.268124924870323,0.904990506905149,0.491695874192756,1.18222496959156,2.78649406493988,1.23993939861951,0.562357055428074,0.430503257061552,0.260471207663241,0.222198950347561,0.244146140244385,0.199930965564885,0.08,0.08,0.280380429079045,0.08,1.29803289775521,0.644877531856651,0.08,1.21892618057074,0.517446550422209,0.286308980255759,1.99552907605479,0.08,0.08,0.08,0.260631123233379,3,1.08287003189374,0.571975967433001,0.602995541483589,0.950851423008591,0.248092489093664,0.724130491811322,0.08,0.08,0.36236286176655,0.08,0.351833995849545,0.08,0.677619591186147,0.999312067809344,3,0.100146428067739,0.24955380708963,0.523560335512138,0.158420246182371,0.215481049205814,0.58588318921722,0.402209146826064,0.727227718053362,0.239804517334702,0.365031683874023,0.575195279321306,0.397217661757939,1.09095255909002,0.08,0.255515727514717,0.281175829775216,0.927598791293162,1.16860696757828,0.363655666812497,0.082581232691638,0.08,0.08,0.08,0.839999306367677,0.538028833513238,0.569024891119325,0.429989853314322,0.163249551913423,0.500535713647252,0.313541498088269,0.244264853282833,0.57207652969541,0.411966608033384,0.815010499470938,0.122190492272561,0.08,0.184091225315847,0.339225918698503,0.483862687289947,0.634317884421984,0.797914170918924,0.133543324755664,3,0.168804123365258,0.08,0.08,0.08,0.229877694516736,0.08,0.914419840030354,0.08,0.343309997244216,0.08,0.261196615437956,0.0872077734062925,0.273404672198033,0.08,0.379758171659058,1.45069623134516,0.403917524429984,0.393938366141701,0.08,0.08,0.359396112609308,1.15639251700037,0.59415989930369,3,0.08,0.456335859869728,0.441690561384803,0.29848371614796,0.412177886044584,0.473437889120972,0.467204116328769,0.08,0.525948295243452,1.03388065332666,0.613711922356677,0.381901682512141,1.61411538232814,0.229360233791999,0.39366564471948,0.08,0.491496797699603,0.497148024534516,0.851813423816534,0.08,0.435036081195241,0.786861118377233,0.651258469535474,0.76469063193795,0.08,2.29321705869185,0.127796130315395,0.146011340006447,0.673814706685647,0.08,0.08,0.441756428956258,0.826654041620123,0.433984610492557,0.266952087416469,0.675799143415301,0.200207191568505,0.455938026675622,0.08,0.08,0.339764250697779,0.287282957907102,0.140141861771829,0.172988438619999,3,0.08,0.465806081297299,1.10308701273994,0.08,0.08,3,0.08,0.188419052322632,0.08,0.690897107434176,0.540420248213257,0.08,0.425993971765802,0.08,0.504258934295203,0.192226617265889,3,0.08,3,0.532965673865309,0.292892484678427,0.740800528141466,0.08,0.520852586409525,0.08,0.08,0.08,1.74193886265121,0.08,0.08,0.362511267191776,0.08,0.761185382551739,1.1773148233796,1.25448948204499,0.340668433947535,0.08,0.08,0.809292200103395,3,0.08,0.225350667945953,0.240868517780859,0.639330678076111,0.364138785251894,0.267983775562788,1.89926492431018,0.08,0.596848984742027,0.08,0.08,0.637875108516337,0.08,0.527267427917297,0.14802498715634,0.826130588347669,0.08,1.16790778591976,1.70243557935703,0.08,1.15321309699228,1.42087389651383,0.772918643242162,0.364915288398906,0.818709406035839,1.69259088279712,0.81886134045052,1.20374404257913,1.69888803799743,0.324896636693861,1.26165815412591,0.538973529797212,0.08,0.28414335895839,0.08,0.08,0.08,0.08,0.08,0.92950286378269,0.08,0.217398003972731,1.78715766602236,0.691056582559961,0.630504932252538,0.190813876960362,0.164108583607229,0.08,0.628395068684299,1.46791081246899,0.500979695346035,0.906014508059735,0.246441769588218,0.255913819657322,0.784097471143874,0.08,0.31937097117667,0.550334500908497,0.655619539114933,0.126044057813085,3,0.453727587602089,1.03807450001919,0.775425800249177,0.08,0.773426965230976,0.257312741564373,0.08,0.08,0.144314523755755,1.31008222130149,0.08,0.08,0.589394624802909,0.08,0.610641611270367,0.28698596652953,0.976858404450431,0.08,0.08,0.08,0.263644557957655,0.08,0.600711731681107,0.08,0.08,0.08,0.220156412762418,0.58414737689552,0.725241985390309,0.439178333379606,0.49160292970286,0.08,0.390615825923273,0.08,0.08,0.08,0.08,0.08,0.08,2.08439972188713,1.07639087423106,1.17410302656232,0.743980534750097,0.653904054951817,0.508197342093113,0.321927151945053,0.374256306181937,0.399351705832201,0.437743834609839,0.585524340722321,0.41137456234372,1.17261693585367,0.712752247099311,0.328418265410607,0.321513378648729,0.653904054951817,0.812945419874063,0.432913501981207,0.238014466470908,0.512992687299726,0.555340854957732,0.364916087033658,0.229779000093477,0.422245554664819,0.368297261612881,1.10406137159818,0.760526323809265,0.379872497937101,0.502433448701211,1.54747889703825,0.660149541830012,0.485521105707184,0.468560452646426,0.266099314061616,0.52149711178228,0.980856082427725,0.980856082427725,0.494658958854802,0.398926007530698,0.308602383644355,0.980856082427725,0.980856082427725,0.751829507235532,0.71730478224182,0.368228812662345,0.401979789208546,0.427078370091415,0.453167148202054,0.902446454717978,0.902446454717978,0.218965843028944,0.388848517088775,0.468263879580724,0.398707699640319,0.538535036268893,0.980856082427725,0.68953932208746,0.86532972225159,0.980856082427725,1.65338253890531,0.458025262558716,0.481921676175243,0.478901524070423,1.10754285786422,0.351149163269433,0.980856082427725,0.341670476222745,0.980856082427725,0.237992740937413,0.254458165531751,0.27049611187343,0.665951458635828,0.566733737966476,0.563045734416391,0.367767028543417,0.751759995522175,0.470050520828389,0.503226267879635,0.767682307110998,0.973221347641644,2.64353881888928,0.303141451956861,0.370297450857431,0.935499378387391,0.980856082427725,0.980856082427725,0.551152620999984,0.4939563214077,0.505833598812626,0.956726805997967,0.442364357446783,0.537695474053737,0.405125784180328,0.324552933177452,0.324552933177452,0.327639841726282,0.327639841726282,0.327639841726282,0.508350680251997,0.518590627563714,0.980856082427725,2.60790379272115,0.465923419751385,0.407479507509605,0.465644201762159,0.513955438039982,0.576079355278205,1.0836495972753,3,0.476133034945673,0.364391262086307,0.385386510789875,0.755450434193843,0.370419421079075,0.54401312111934,1.17691673535919,0.634556081779549,0.287403649533109,1.82347400152938,0.549748340876334,0.705582224918105,0.39734505162665,0.39652670144596,0.315278074200773,0.41982358099207,0.344564452618409,0.550850326908173,0.377323631116242,0.589441422626001,0.506312425803444,0.425907778042213,0.618236689184217,0.329434239090806,0.595001755919266,0.332892167688036,0.712752247099311,0.61306515491664,0.96906519231721,0.42559554095743,0.716381361258095,0.268126996092298,0.888958601047252,0.440294520565645,0.442425703212989,0.455612923663306,0.655396261187921,0.440460546567234,0.408549163351184,0.403953419439752,0.531901343374264,0.08,0.316200306517359,0.30202946445952,0.549748340876334,0.417436973652695,0.870947551434932,0.464109665394857,0.622284152261692,0.85879776412035,0.34560079114526,0.959461993504027,0.753082425149504,1.20774186510716,1.0908630832192,1.74030205388729,1.51780838982777,0.842700487663653,2.07589307286042,0.458503610171182,0.393528625800312,1.0947128365355,0.217131809521322,1.37186792306449,1.12548494500078,0.366384544962757,0.670671492091726,0.545121770792288,0.614945671688851,0.08,0.376017830004152,0.332228327394677,1.18575647651991,1.04559677260639,0.154901357380935,0.312170872908221,0.37124619564285,0.290017264961554,1.26355015553958,0.623837190657913,2.59486634107552,1.40411440001774,0.760360002973652,0.946822527718813,0.669258239860149,1.356461791391,0.319875023634822,0.612511782961462,1.3575097389728,0.711560535043352,0.360557653697106,2.76060858162305,0.209250863456962,0.583626607747806,0.263580215726443,0.583631661714968,0.08,0.980856082427725,0.590041825976151,0.212466523390837,0.565359604527108,1.49812891833521,0.369190737413911,1.34202561663246,1.01088485213918,1.56593560465676,0.466696681860728,0.515444151217495,0.980856082427725,0.980856082427725,0.980856082427725,1.33729120891949,0.940796468937959,0.344532886235771,0.821325653393856,0.670829156141824,0.381257578048426,0.322364568309762,0.554556956661232,0.843410803766227,0.833914543511461,0.483277187609828,0.38428857242605,0.580813380879889,0.33892608618125,2.09020041327391,2.95063455929472,1.01472548865634,0.93982553483353,0.729623065071149,0.312530233617023,0.440197835064153,0.657277150150447,0.555020721048358,0.404615919497303,0.551506745873752,0.695443331897628,0.564114851758425,0.454804517733003,0.182428224148346,0.189461761325974,1.54184649041762,0.213928300330183,0.471375290875952,0.921617867802757,0.731255371955576,0.519374202591597,0.636982243803138,0.352845106581377,0.349347131355693,0.640315252365507,0.670732279354118,0.31263887155438,1.24186060731633,0.940675576780453,0.08,0.08,0.724348368245813,0.914034782523599,0.354254305006941,0.44257257982648,0.513949900891905,0.589978388164622,0.984332230067246,2.10699223878954,1.03656976617667,0.439680844671609,0.473059303705143,0.210207859291711,0.176000055506395,0.3649967820128,0.08,0.278195073751107,1.34809482720652,0.127337678176073,0.818371221355678,0.50810674989934,0.498020841739524,0.539100489645805,0.571935710143269,2.47695103283569,0.140266162918202,1.69446280956997,0.372050852155253,0.639367283212514,0.08,0.08,0.08,0.957425492860454,0.781332350474841,0.295801697947861,0.466792243307594,0.157559248532142,0.28023133406473,0.46849377620107,0.772918643242162,0.470909359312462,0.908661277044529,0.08,0.59014135932014,0.492723782352624,0.574470534387148,0.953104171781509,1.11639227623308,0.172255408396951,0.463982343122288,0.760371244704054,0.985926411289524,0.380714389091436,0.376342891392084,0.579586149645507,1.30325864709555,2.18573670805415,0.08,0.448630223861578,0.08,0.08,1.07122913570503,0.45249943321807,0.256100150375998,0.268732683501547,0.247846618044608,0.197519573604087,1.47056416318041,0.345818157204916,1.66116116186487,0.223612175196797,0.266242660281488,0.707659628169837,0.286634812720547,0.751122323499154,0.420492901856628,0.546498514780516,0.467427861991605,0.398391482667818,0.476085207809438,0.516627749979767,0.08,0.742918122978906,3,0.399140205119367,0.443151791933863,0.08,0.963487615295304,0.556310329005582,0.874761595266761,0.411899749089941,0.08,0.592511029511414,0.894112760587401,1.48146161235447,0.192073649595151,0.145759790117923,0.08,1.07988582769595,0.606255074615534,0.591007391757036,0.334734268203916,0.409545820710936,1.12192441841106,0.980856082427725,0.329196172078178,0.496656119747138,0.778263574763928,0.08,0.255515727514717,0.97808681816207,0.707635257947073,0.774958568091334,0.460421895904442,0.993816011978661,2.7192368164396,0.254593997619485,0.347780412918079,3,0.449673572431918,1.36100102803946,0.219435218029568,0.08,1.12856891024591,1.57670733640089,0.08,0.08,0.661649955217098,0.300513271147279,1.55720877999934,1.60056313297816,0.401326676075611,0.250492788702648,0.583206183513954,0.673803506481417,0.5613549349185,0.734089023481253,1.04838741727464,0.534964318150951,0.506373214953398,1.48554394293395,0.323825149614436,0.161444792502682,0.08,0.08,0.568140571036034,0.08,0.08,0.504678382321476,0.634783974646795,0.08,0.297605305506996,0.88446627767418,0.490047733369921,0.442954809578426,0.324623084306943,3,0.08,0.08,0.366860901506234,0.503388634077238,0.297136203561879,3,0.366250247479295,0.347851539522476,0.562699099081647,0.08,0.614993108637154,0.281352984675902,0.222198950347561,0.605406912081112,0.345007322825677,1.29111721560271,1.4228140962937,0.08,0.08,3,0.756128856050603,0.08,0.364945543647493,0.872819606753036,0.576186063240008,0.995471687512708,0.999554926896484,0.43580677043453,1.31475518208643,0.545765966937337,1.65794041176178,2.72812498648521,0.457828365876655,0.639255739039516,1.26064070744237,0.326352246705917,0.563947984279732,0.08,0.08,0.08,0.630184460027027,1.58266713683282,0.847177601669505,1.37090559152089,0.638276527492502,0.580394818325698,0.08,0.08,0.08,0.62491523967452,0.672627640148266,0.08,0.08,0.341270450976782,0.793765300095664,0.08,0.350995100029041,0.720891578534723,0.886516907677384,0.763789461094772,0.497087234720802,0.445808289833565,0.08,0.597279973015142,0.952664846096151,0.08,0.488389773246562,1.56331493967986,0.08,2.20404863752251,0.67535036617001,0.765718760711208,0.960793443494724,0.437899975214225,0.142638422310682,0.08,3,0.08,0.08,0.08,0.08,0.467742190091736,0.466585234992678,0.426638974384602,1.32250515163161,0.96994438575962,0.612809586620725,0.490265382861176,1.44412328351624,0.778337047130395,0.23114278559993,0.08,0.439592393270232,0.186257649692443,0.357832411881056,0.573097923926026,0.271735704859757,0.853365353346115,0.842686613655804,0.08,1.07115588812588,1.66889562355265,1.14313875746939,0.08,0.08,0.08,0.08,0.0818187876471125,0.741023348654103,1.83234222762282,0.283216812170994,0.594757137335987,0.529938861471152,0.08,0.08,0.08,0.08,0.809728396070299,0.571244137098088,0.635481611999088,0.34818543227846,0.248370925848648,0.504258934295203,0.08,0.08,0.08,0.384503052246737,1.39251171395955,0.221569424663764,0.08,0.1929134989992,1.4025237213168,2.12463368313577,1.05539056215526,3,0.840306472724732,1.65304354992203,0.08,3,0.236624384427832,0.444294285358384,0.637420719043014,0.08,0.792332320485205,0.346209285891986,0.08,0.08,0.521627534680956,2.93477705546305,1.44350975295847,0.35805500707192,0.278404066686262,1.70454017152442,0.08,0.315077634877461,1.11885001541779,0.474151148928055,0.276811166070427,1.98953296761834,2.96099169876406,0.37461983626575,1.23642286604189,0.695882287315081,0.141679010948595,0.08,0.762873577159955,0.258704184916878,0.95923279578561,0.65368681992343,0.08,0.367851854974447,0.493234412665995,0.752757923211545,0.56009995153859,0.08,0.08,0.566242476329355,0.680874838052414,0.865658801181623,1.39635629328892,1.23771132529373,0.599514615459696,0.306918166253945,0.438941572487447,1.69259769756753,0.505627140165531,0.258165634967629,0.863884908258599,0.352082063586833,0.08,0.08,0.08,0.08,1.24547151061922,0.730484103177291,1.19416242160893,0.448365549194337,0.146627081865828,0.293293270750874,0.267601447795022,0.139605969987964,0.391832565091001,0.393573693981072,0.235533393400343,0.08,0.08,0.60790924048642,0.800491572869103,0.89482621363435,0.464966441853824,1.1323635479739,0.963030724441304,0.08,0.350183712002312,0.08,0.48319703530523,0.08,0.08,0.08,0.997223310039226,0.989918521503862,0.08,0.08,0.394362217860543,0.08,0.08,0.544404332612542,0.345277275881159,0.30508285440632,0.08,0.273501512477458,0.08,0.534766589995165,1.72582327186961,0.49467574340906,0.08,0.85837444856884,0.08,0.501837554015169,0.786293144982848,1.34101342780229,0.08,0.461158555094738,0.253362913485636,0.70639537883293,3,0.234296851377356,1.34605679321691,0.985360086012469,0.08,0.805049130644706,0.930016635887544,0.353157019923881,1.28606908013484,0.411087243799786,0.170775493376635,3,3,0.08,0.08,0.08,0.527821028607964,0.08,0.08,0.08,2.84734247744609,0.526516102043454,0.08,0.28255339600848,0.403164293950386,1.25397012289795,0.08,0.08,0.402710907261791,0.08,0.839672341244865,2.96885834788209,3,0.08,0.48376947950407,0.08,0.08,0.08,0.08,0.08,0.08,0.754975542460652,0.434895703742818,0.364786153492785,0.358324877761935,0.08,0.310726883994864,0.915067192258964,0.672121022589312,0.217269339500071,0.53076512012436,0.775829042106073,0.492810611360037,3,0.577323911157926,0.231726808298636,1.33455963333214,1.22879391690324,0.08,0.08,0.838036832301196,1.34828645185873,0.08,0.378423442701584,0.08,0.330136222069624,0.347147601082108,0.08,0.269213693103685,0.44323847978469,2.75844445042338,1.93736215188681,0.08,0.08,0.124591141644407,0.08,0.08,0.08,0.08,0.44606785300199,0.08,0.08,0.08);
/*0.00, 
0.08, 
0.00, 
0.75, 
0.76, 
0.60, 
0.75, 
0.47, 
0.64, 
0.53, 
0.41, 
0.47, 
0.62, 
0.47, 
0.49, 
0.30, 
0.29, 
0.27, 
0.30, 
0.39, 
0.00, 
0.22, 
0.25, 
0.46, 
0.00, 
0.40, 
0.00, 
0.00, 
0.19, 
0.00, 
0.00, 
0.14, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.10);*/
/*0.00, 
0.00, 
0.00, 
0.75, 
0.76, 
0.48, 
0.55, 
0.44, 
0.56, 
0.53, 
0.39, 
0.47, 
0.47, 
0.56, 
0.50, 
0.39, 
0.33, 
0.28, 
0.49, 
0.28, 
0.45, 
0.26, 
0.18, 
0.26, 
0.29, 
0.00, 
0.25, 
0.12, 
0.00, 
0.32, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.10, 
0.15, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.00, 
0.08);*/
      f.write("//begin combination function\n");

      val ands = getAnds(goal);//get a list of the anded predicates
      var nonRelationsMap : Map[FolExpression, Set[Variable]] = Map();
      var relationsMap : Map[FolExpression, Set[Variable]] = Map();//relation predicates are 2 valued and start with r_. 
      															//e.g: agent, patient, in, ...
      var notEqMap : Map[FolExpression, Set[Variable]] = Map();//expressions of the form !(x1=x2)
      var impMap : Map[FolExpression, Set[Variable]] = Map();//expressions of the form a->(b^c^...)
      
      for(expr <- ands )
      {
        val allVars = findAllVars(expr); 
        expr match
        {
	      case FolApplicationExpression(fun, arg) =>{
		        fun match {
		          case FolApplicationExpression (fun2, arg2) =>
		            fun2 match {
		              case FolVariableExpression(v) =>{
		            	  if (v.name.startsWith("r_"))
		            	    relationsMap = relationsMap + ( expr -> allVars);
		            	  else
		            	    nonRelationsMap = nonRelationsMap + ( expr -> allVars);
		              }		                
		              case _ => nonRelationsMap = nonRelationsMap + ( expr -> allVars);
		            }
		          case FolVariableExpression(v) =>{
		        	  if (!v.name.startsWith("topic_"))
		        		  nonRelationsMap = nonRelationsMap + ( expr -> allVars);
		          }
		          case _=>  nonRelationsMap = nonRelationsMap + ( expr -> allVars); 
		        }
	        }
	      case FolEqualityExpression(first, second)=>; //delete equality expressions because it is already handeled by renaming variables
	      case FolAllExpression(first, second)=>  impMap  = impMap + ( expr -> allVars);
	      case FolNegatedExpression(term)=> {
	        term match {
	          case FolEqualityExpression(first, second) => notEqMap  = notEqMap + ( expr -> allVars);
	          case _ => nonRelationsMap = nonRelationsMap + ( expr -> allVars); //this case will be changed later
	        }
	      };
	      case _ => nonRelationsMap = nonRelationsMap + ( expr -> allVars);
        }
      }
      
      //number of a->ent rules is not = number of anded predicates
      //val n = coundAnd(goal);
      var n = 0;
      for(nonRelationExpr<- nonRelationsMap )
      {
    	  var printedAtLeastOnce = false;
	      for(relationExpr<- relationsMap )
	      {
	    	  if ((nonRelationExpr._2 & relationExpr._2).size != 0)
	    	  {
	    		  printedAtLeastOnce = true;
	    		  n = n +1 ;
	    	  }
	      }
	      if (!printedAtLeastOnce)
	        n = n +1 ;
      }
      n += notEqMap.size;   //Each notEqual expression corresponds to an extra line in the combination function
      n += impMap.size;   //Each imp expression corresponds to an extra line in the combination function
      						//THis may change
      //println("//n: " + n +"\n");
      //AlchemyTheoremProver.pairIndx
      //entWeight  = entWeights(AlchemyTheoremProver.pairIndx)
      //if n is not in the list of weights, set it to 1

      val maxProb = Sts.opts.get("-maxProb") match {
         case Some(prob) => prob.toDouble;
         case _ => 0.95;
      }     

      if (n >= entWeights.size)
    	  entWeight = (-prior + log(maxProb) - log(1-maxProb))/n;
      else
    	  entWeight = entWeights(n);
      if (entWeight == 0)
      	  entWeight = (-prior + log(maxProb) - log(1-maxProb))/n;
      
      val allGoalVariables: Set[Variable] = findAllVars(goal);      

      //write relation predicates
      for(nonRelationExpr<- nonRelationsMap )
      {
    	  var printedAtLeastOnce = false;
	      for(relationExpr<- relationsMap )
	      {
	    	  if ((nonRelationExpr._2 & relationExpr._2).size != 0)
	    	  {
	    		  f.write(entWeight + "  " + convert((nonRelationExpr._1 & relationExpr._1) -> entailmentConsequent, allGoalVariables) + "\n");
	    		  printedAtLeastOnce = true;
	    	  }
	      }
	      if (!printedAtLeastOnce)
	        f.write(entWeight + "  " + convert(nonRelationExpr._1 -> entailmentConsequent, allGoalVariables) + "\n");
      }
      
      //write notEqual predicates
      for(notEqExpr <- notEqMap )
      {
          var oneLine = notEqExpr._1;
          var foundOne = false;
	      for(nonRelationExpr <- nonRelationsMap )
	      {
	    	  if ((notEqExpr._2 & nonRelationExpr._2).size != 0)
	    	  {
	    		  oneLine = oneLine & nonRelationExpr._1;
	    		  foundOne = true;
	    	  }
	      }
	      if (foundOne)
	    	  f.write(entWeight + "  " + convert(oneLine -> entailmentConsequent, allGoalVariables) + "\n");
      }
      
      //write imp expressions 
      for(impExpr <- impMap )
      {
	      f.write(entWeight + "  " + convert(impExpr._1 -> entailmentConsequent, allGoalVariables) + "\n");
      }
      
      
      //f.write(average(goal));  a->ent, where a is one of the anded formulas
      f.write("//end combination function\n");

      //normal anding
      //f.write("// " + convert(universalifyGoalFormula(goal -> entailmentConsequent)) + ". //(ditAnd)\n")
      /*
      f.write("//begin evd part\n");
      evidence.foreach {
        case e @ FolAtom(pred, args @ _*) => f.write(convert(e) + ".\n")
        case e => throw new RuntimeException("Only atoms may be evidence.  '%s' is not an atom.".format(e))
      }   
      f.write("//end evd part\n");
      */
    }
    tempFile
  }

  private def universalifyGoalFormula(goalFormula: FolIfExpression) = {
    val FolIfExpression(goal, consequent) = goalFormula

    def isConjoinedAtoms(e: FolExpression): Boolean = {
      e match {
        case FolAtom(_, _*) => true
        case FolAndExpression(a, b) => isConjoinedAtoms(a) && isConjoinedAtoms(b)
        case _ => false
      }
    }

    def universalify(e: FolExpression): FolExpression = {
      e match {
        case FolExistsExpression(v, term) => FolAllExpression(v, universalify(term))
        case _ if isConjoinedAtoms(e) => e -> consequent
        case _ => e -> consequent // sys.error(e.toString)
      }
    }

    universalify(goal)
  }

  private def makeEvidenceFile(evidence: List[FolExpression]) = {
    val tempFile = FileUtils.mktemp(suffix = ".db")
    FileUtils.writeUsing(tempFile) { f =>
      f.write("//\n");
      evidence.foreach {
        case e @ FolAtom(pred, args @ _*) => f.write(convert(e) + "\n")
        case e => throw new RuntimeException("Only atoms may be evidence.  '%s' is not an atom.".format(e))
      }
    }
    
    tempFile
  }

  private def callAlchemy(mln: String, evidence: String, result: String, args: List[String] = List()): Option[String] = {
    if (LOG.isDebugEnabled) {
      LOG.debug("mln file:\n" + readLines(mln).mkString("\n").trim)
      LOG.debug("evidence file:\n" + readLines(evidence).mkString("\n").trim)
    }

    //lifted belife propagation works better
    //val allArgs = "-bp" :: "-lifted" :: "-i" :: mln :: "-e" :: evidence :: "-r" :: result :: args;
    //Dunno, but it seems that MC-SAT is better
    //val allArgs = "-ptpe" :: "-i" :: mln :: "-e" :: evidence :: "-r" :: result :: args;
    val allArgs = "-i" :: mln :: "-e" :: evidence :: "-r" :: result :: args;
    //val (exitcode, stdout, stderr) = callAllReturns(None, allArgs, LOG.isDebugEnabled, false);
    val (exitcode, stdout, stderr) = callAllReturns(None, allArgs, false);

    val results = readLines(result).mkString("\n").trim

    LOG.debug("results file:\n" + results)

    exitcode match {
      case 0 => Some(results)
      case _ => throw new RuntimeException("Failed with exitcode=%s.\n%s\n%s".format(exitcode, stdout, stderr))
    }
  }
  
  //find outer most variables in the exist clauses
  private def findVars(input: FolExpression, bound: Set[Variable] = Set()): Set[Variable] =
	input match {
	  case FolExistsExpression(variable, term) => findVars(term, bound+variable)
	  case _ => bound
  }
  
  //find all variables used in the clause
  private def findAllVars(input: FolExpression): Set[Variable] =
  {
	input match {
      case FolExistsExpression(variable, term) => findAllVars(term) + variable;
      case FolAllExpression(variable, term) => findAllVars(term) + variable;
      case FolNegatedExpression(term) => findAllVars(term);
      case FolAndExpression(first, second) => findAllVars(first) ++ findAllVars(second);
      case FolOrExpression(first, second) => findAllVars(first) ++ findAllVars(second);
      case FolIfExpression(first, second) => findAllVars(first) ++ findAllVars(second);
      case FolIffExpression(first, second) => findAllVars(first) ++ findAllVars(second);
      case FolEqualityExpression(first, second) => findAllVars(first) ++ findAllVars(second);
      case FolApplicationExpression(fun, arg) =>{
        fun match {
          case FolVariableExpression (v) => findAllVars(arg);
          case _=> findAllVars(arg) ++ findAllVars(fun);
        }
      }
      //case FolAtom(pred, args) =>  
      case FolVariableExpression(v) => Set(v);
      case _ => {
    	  println(input.toString());
    	  Set();
      } 
    }
  }
  
  //count the anded predicates
  private def coundAnd(input: FolExpression): Int =
	input match {
	  case FolExistsExpression(variable, term) => coundAnd(term)
	  case _ => _coundAnd(input)
  }  
  private def _coundAnd(input: FolExpression ): Int =
	input match {
	  case FolAndExpression(first, second) => _coundAnd(first) +  _coundAnd(second) 
      case _ => 1
  }

  //get a list of the anded predicates
  private def getAnds(input: FolExpression): List[FolExpression] =
    input match {
      case FolExistsExpression(variable, term) => getAnds(term) // don't add outermost 'exist'
      case _ => _getAnds(input)
    }

  private def _getAnds(input: FolExpression): List[FolExpression] =
    input match {
      case FolAndExpression(first, second) => _getAnds(first) ++  _getAnds(second) 
      case _ => List(input);
    }
  
  
  //average instead of anding 
  private def average(input: FolExpression, bound: Set[Variable] = Set()): String =
    input match {
      case FolExistsExpression(variable, term) => average(term, bound + variable) // don't add outermost 'exist'
      case _ => _average(input, bound)
    }

  private def _average(input: FolExpression, bound: Set[Variable]): String =
    input match {
      case FolAndExpression(first, second) => _average(first, bound) +  _average(second, bound)
      //case _ => entWeight + "  " + _convert(input -> entailmentConsequent, bound) + "\n"
      case _ => entWeight + "  " + convert(universalifyGoalFormula(input -> entailmentConsequent), bound) + "\n"
      
      /*case FolExistsExpression(variable, term) => "exist " + variable.name + " (" + _convert(term, bound + variable) + ")"
      case FolAllExpression(variable, term) => "forall " + variable.name + " (" + _convert(term, bound + variable) + ")"
      case FolNegatedExpression(term) => "!(" + _convert(term, bound) + ")"
      case FolAndExpression(first, second) => "(" + _convert(first, bound) + " ^ " + _convert(second, bound) + ")"
      case FolOrExpression(first, second) => "(" + _convert(first, bound) + " v " + _convert(second, bound) + ")"
      case FolIfExpression(first, second) => "(" + _convert(first, bound) + " => " + _convert(second, bound) + ")"
      case FolIffExpression(first, second) => "(" + _convert(first, bound) + " <=> " + _convert(second, bound) + ")"
      case FolEqualityExpression(first, second) => "(" + _convert(first, bound) + " = " + _convert(second, bound) + ")"
      case FolAtom(pred, args @ _*) => pred.name.replace("'", "") + "(" + args.map(v => if (bound(v)) v.name else quote(v.name)).mkString(",") + ")"
      case FolVariableExpression(v) => if (bound(v)) v.name else quote(v.name)
      */
    }

  //convert a FOLExpression to an alchamy string 
  private def convert(input: FolExpression, bound: Set[Variable] = Set()): String =
    input match {
      case FolAllExpression(variable, term) => convert(term, bound + variable) // don't add outermost 'forall'
      case _ => _convert(input, bound)
    }

  private def _convert(input: FolExpression, bound: Set[Variable]): String =
    input match {
      case FolExistsExpression(variable, term) => "exist " + variable.name + " (" + _convert(term, bound + variable) + ")"
      case FolAllExpression(variable, term) => "(forall " + variable.name + " (" + _convert(term, bound + variable) + "))"
      case FolNegatedExpression(term) => "!(" + _convert(term, bound) + ")"
      case FolAndExpression(first, second) => "(" + _convert(first, bound) + " ^ " + _convert(second, bound) + ")"
      case FolOrExpression(first, second) => "(" + _convert(first, bound) + " v " + _convert(second, bound) + ")"
      case FolIfExpression(first, second) => "(" + _convert(first, bound) + " => " + _convert(second, bound) + ")"
      case FolIffExpression(first, second) => "(" + _convert(first, bound) + " <=> " + _convert(second, bound) + ")"
      case FolEqualityExpression(first, second) =>
        	"(" + _convert(first, bound) + " = " + _convert(second, bound) + ")";	
        	//both variables of the same type
	        /* This part is not needed anymore because we do not have separate types for Events and Indvs anymore. 
	        * if (first.asInstanceOf[FolVariableExpression].variable.name.charAt(1) == 
	        		second.asInstanceOf[FolVariableExpression].variable.name.charAt(1))
	        	"(" + _convert(first, bound) + " = " + _convert(second, bound) + ")";
	        else
	        	// dummy exp
	        	"(" + _convert(first, bound) + " = " + _convert(second, bound) + ")";
	        */
      case FolAtom(pred, args @ _*) => pred.name.replace("'", "") + "(" + args.map(v => if (bound(v)) v.name.toLowerCase() else quote(v.name)).mkString(",") + ")"
      case FolVariableExpression(v) => if (bound(v)) v.name.toLowerCase() else quote(v.name)
    }

  private def quote(s: String) = '"' + s + '"'

}

object AlchemyTheoremProver {

  private var pairIndx = 0;

  def findBinary(binDir: Option[String] = None, envar: Option[String] = Some("ALCHEMYHOME"), verbose: Boolean = false) =
  {    //new AlchemyTheoremProver(FileUtils.findBinary("liftedinfer", binDir, envar, verbose))
	pairIndx = pairIndx+1;
	//println("pairIndx: " + pairIndx);
    new AlchemyTheoremProver(FileUtils.findBinary("infer", binDir, envar, verbose))
  }

  def main(args: Array[String]) {
    val parse = new FolLogicParser().parse(_)

    val atp = new AlchemyTheoremProver(pathjoin(System.getenv("HOME"), "bin/alchemy/bin/infer"))

    val constants = Map("ind" -> Set("Socrates"))
    val declarations = Map[FolExpression, Seq[String]](FolAtom(Variable("man")) -> Seq("ind"), FolAtom(Variable("mortal")) -> Seq("ind"))
    val evidence = List("man(Socrates)").map(parse)
    val assumptions = List(HardWeightedExpression(parse("all x.(man(x) -> mortal(x))")))
    val goal = parse("mortal(Socrates)")
    println(atp.prove(constants, declarations, evidence, assumptions, goal))

  }
}
